## 로직 게이트 생성기 기획서 요약 (최종)

**1. 프로젝트 개요**

본 프로젝트는 Unity 엔진을 사용하여 퍼즐 게임의 문제로 활용될 복잡하고 최적화되지 않은 논리 회로를 랜덤하게 생성하고, 생성된 회로 구조, 해당 불 대수식, **진리표**, 그리고 회로의 복잡성 지표를 출력하는 도구를 개발합니다.

**2. 플랫폼**

Unity 엔진을 사용하여 로직 게이트 생성 도구를 개발합니다.

**3. 기능 설명**

* **사용자 입력:**
    * 입력 변수 개수 ($n$)
    * 출력 변수 개수 ($m$)
    * 총 게이트 레이어 수
    * 각 게이트 레이어당 게이트 개수 (레이어 수만큼 개수 지정)
    * (선택 사항) 사용될 게이트 타입 비율 조정 (예: AND 30%, OR 30%, XOR 20%, XAND 10%, NOT 5%, Wire 5%)
* **출력:**
    * **생성된** 복잡한 불 대수식을 문자열 형태로 표시
    * **생성된 회로의 진리표**
    * 생성된 회로의 구조 및 복잡성 지표 (게이트별 점수 합산 등) 표시
    * 콘솔 출력 및 JSON 파일로 저장 (회로 구조, 불 대수식, 복잡성 지표, 진리표 포함)

**4. 로직 회로 생성**

사용자 지정 조건에 따라 출력부에서 입력부 방향으로 회로를 생성합니다. 일반적인 DAG(Directed Acyclic Graph) 회로 구조를 목표로 합니다.

* **사용될 게이트 타입:** AND, OR, XOR, **XAND**, NOT, Wire
    * AND, OR, XOR, **XAND**는 2-입력 게이트입니다.
    * NOT, Wire는 1-입력 게이트입니다.
    * Wire는 1-입력, 1-출력으로 입력값을 그대로 전달하는 버퍼 역할을 합니다.
* **생성 절차 (출력 -> 입력 방향):**
    1.  **출력 노드 생성:** `m`개의 최종 출력 노드를 생성합니다.
    2.  **게이트 레이어 역방향 생성 및 연결:** 사용자가 지정한 `총 레이어 수`만큼, 마지막 레이어부터 첫 번째 레이어까지 역방향으로 게이트 레이어를 생성하고 이전 레이어(출력 방향)와 연결합니다. (상세 절차는 기존 설명 참고, 게이트 타입 목록에 XAND 포함)
    3.  **입력 변수 노드 생성:** `n`개의 입력 변수 노드를 생성합니다.
    4.  **입력 변수 연결 (가장 첫 게이트 레이어 - Layer 1):** Layer 1의 게이트들의 입력을 입력 변수 노드에 연결합니다. **제약 조건 1 (모든 입력 변수 최소 1개 게이트에 연결)**과 **제약 조건 2 (동일 게이트의 두 입력에 같은 변수 연결 불가)**를 만족하도록 처리합니다. (개발 용이성을 위한 2-Phase 접근 방식 사용)

**5. 트리와 수식 변환**

* **트리 → 수식:** 생성된 회로 구조 (DAG 형태)를 역방향으로 재귀 탐색하여 불 대수식을 문자열로 변환합니다. 연산 우선순위를 명확히 나타내기 위해 괄호를 적절히 사용하며, XAND 연산도 올바르게 표현합니다.
* ~~**수식 → 트리:**~~ (최적화 기능 삭제로 인해 필요성 감소, 기능 제외)

**6. 진리표 생성 및 정답 확인**

* **필수 기능:** 플레이어가 완성한 회로의 정답 여부를 확인하기 위해 진리표를 생성하는 것은 필수 기능입니다.
* **진리표 생성 방식:** 입력 변수 개수($n$)에 따른 $2^n$개의 모든 입력 조합에 대해 회로의 동작을 시뮬레이션하여 출력 값을 계산하는 **브루트 포스 기반 시뮬레이션 방식**을 사용합니다.
* **효율성 고려 (비트 연산 활용):** 퍼즐 게임 문제의 특성상 입력 변수 개수($n$)가 인간이 다루기 용이한 수준(예: 10~15개 이내)으로 제한될 가능성이 높습니다. 이 범위에서 $2^n$ 조합의 수는 PC가 충분히 빠르게 처리할 수 있는 수준이므로, 브루트 포스 시뮬레이션 방식은 효율성 측면에서 문제가 없습니다. 특히, 각 게이트의 논리 연산을 C#의 비트 연산자(`&`, `|`, `^`, `~`)로 직접 구현하여 시뮬레이션 성능을 더욱 최적화할 수 있습니다.
* **진리표 생성 과정 수도 코드 (예시: 입력 5, 출력 5, 레이어 5, 레이어당 게이트 5개 회로):**

```pseudocode
// 회로 구조는 미리 파싱되어 노드와 연결 정보로 표현되어 있다고 가정
// input_nodes: 입력 변수 노드 리스트 (n개)
// output_nodes: 출력 변수 노드 리스트 (m개)
// ordered_nodes: 입력 -> 출력 방향 순서로 정렬된 모든 노드 리스트 (입력 노드, 게이트 노드 순)

// 진리표를 저장할 리스트 초기화
TruthTable = [] // 각 항목은 [입력 조합 (정수), 출력 결과 (정수)] 형태

// 모든 가능한 입력 조합에 대해 반복 (0부터 2^n - 1까지)
num_inputs = input_nodes.Count // 예: 5
num_outputs = output_nodes.Count // 예: 5
total_combinations = 2 ^ num_inputs // 예: 2^5 = 32

FOR input_pattern FROM 0 TO total_combinations - 1
    // 현재 입력 조합에 대한 노드별 값을 저장할 맵
    // 각 값은 0 또는 1의 정수 (비트)
    NodeValues = Map<Node, Integer>()

    // 1. 입력 변수 값 설정 (비트 추출)
    FOR i FROM 0 TO num_inputs - 1
        input_value = (input_pattern >> i) & 1
        NodeValues[input_nodes[i]] = input_value

    // 2. 노드 값 순차적 계산 (값 전파 - 입력 노드부터 순서대로)
    // ordered_nodes는 입력 노드들 다음에 게이트들이 의존성 순서대로 와야 함
    FOR EACH node IN ordered_nodes
        // 입력 노드는 이미 값이 설정됨
        IF node IS NOT an InputNode
            input_values = List<Integer>()
            // 현재 노드(게이트)의 각 입력 포트에 연결된 소스 노드의 값을 가져옴
            FOR EACH input_port IN node.input_ports
                source_node = input_port.source_node
                input_values.Add(NodeValues[source_node]) // 소스 노드의 계산된 값 가져옴

            // 노드 타입(게이트 타입)에 따라 비트 연산으로 출력 값 계산
            output_value = 0
            IF node.type IS AND      output_value = input_values[0] & input_values[1]
            ELSE IF node.type IS OR   output_value = input_values[0] | input_values[1]
            ELSE IF node.type IS XOR  output_value = input_values[0] ^ input_values[1]
            ELSE IF node.type IS XAND output_value = (input_values[0] ^ input_values[1]) ^ 1 // XOR 후 비트 부정
            ELSE IF node.type IS NOT  output_value = input_values[0] ^ 1 // 비트 부정
            ELSE IF node.type IS Wire output_value = input_values[0] // 값 그대로

            // 계산된 노드 출력 값 저장
            NodeValues[node] = output_value

    // 3. 최종 출력 값 기록
    output_result = 0 // num_outputs 비트 정수로 표현
    FOR i FROM 0 TO num_outputs - 1
        // 최종 출력 변수 노드는 특정 게이트 노드에 연결되어 있음
        source_node = output_nodes[i].source_node
        output_value = NodeValues[source_node] // 연결된 게이트의 최종 계산 값 가져옴

        // 출력값을 output_result 정수의 해당 비트에 설정
        output_result = output_result | (output_value << i)

    // 진리표에 현재 입력과 계산된 출력 결과 추가
    // 입력 결과는 input_pattern 정수, 출력 결과는 output_result 정수로 저장
    TruthTable.Add([input_pattern, output_result])

RETURN TruthTable // 2^n 개의 항목을 가진 진리표 반환

```
* **정답 확인 활용:** 생성된 진리표는 플레이어의 회로가 정확한 논리 기능을 수행하는지 확인하는 데 사용됩니다. 플레이어의 회로에 대한 진리표를 생성하고, 생성된 문제 회로의 진리표와 비교하여 일치하는지 확인합니다.

**7. 회로 난이도 및 복잡성 측정**

* **개요:** 생성된 회로의 퍼즐 난이도를 대략적으로 파악하기 위해, 회로를 구성하는 각 게이트 타입에 **난이도/복잡성 점수**를 할당하고, 이를 기반으로 회로 전체의 복잡성 지표를 계산합니다.
* **게이트별 난이도 점수 정의:** (기존과 동일, XAND 포함)

    | 게이트 타입 | 설명                      | 입력 수 | 제안 점수 | 비고                                     |
    | :---------- | :------------------------ | :------ | :-------- | :--------------------------------------- |
    | Wire        | 입력값 그대로 출력        | 1       | 1         | 가장 단순한 통과                         |
    | NOT         | 논리 부정                 | 1       | 1         | 기본적인 단항 연산                       |
    | AND         | 논리곱                    | 2       | 2         | 기본적인 2항 연산                        |
    | OR          | 논리합                    | 2       | 2         | 기본적인 2항 연산                        |
    | **XAND** | **배타적 논리합의 부정 (XNOR)** | **2** | **3** | XOR과 논리적 복잡성 유사, 2항 연산 중 복잡 |
    | XOR         | 배타적 논리합             | 2       | 3         | AND, OR, NOT 조합으로 구현 시 더 복잡    |

* **회로 전체 복잡성 지표:** 회로에 사용된 모든 게이트의 난이도 점수를 합산하는 방식 등을 사용합니다.

**8. 출력 형식**

* **콘솔 출력:** 생성된 논리식, 회로의 간단한 구조 정보, 복잡성 지표, **진리표 (작은 규모의 경우)**를 콘솔에 출력합니다.
* **JSON 파일 출력:**
    * 생성된 로직 회로의 구조 (노드 타입, 게이트 타입, 연결 정보 등)를 JSON 형식으로 저장합니다.
    * 생성된 불 대수식 문자열을 JSON에 포함합니다.
    * 계산된 회로 복잡성 지표를 JSON 데이터에 포함합니다.
    * **생성된 진리표를 JSON 데이터에 포함합니다.** (예: 입력 패턴 리스트와 각 패턴에 대한 출력 패턴 리스트 형태로)

**9. C# 코드 구현 개요**

* `Node` (또는 `CircuitObject`): 회로 구성 요소(입력, 출력, 게이트)의 기본 클래스.
* `InputNode`, `OutputNode`: 입력 변수 및 출력 지점을 표현하는 클래스. OutputNode는 자신의 SourceNode (연결된 게이트 출력) 참조를 가집니다.
* `GateNode`: 논리 게이트(AND, OR, XOR, XAND, NOT, Wire)를 표현하는 클래스. 게이트 타입, 입력 포트 목록 (`List<InputPort>`), 출력 포트 정보, 자신의 난이도 점수 속성을 가집니다.
* `InputPort`: 게이트의 입력 포트를 표현하는 클래스. 연결된 SourceNode (이전 레이어의 게이트 출력 또는 입력 변수) 참조를 가집니다.
* `CircuitGenerator`: 사용자 입력을 받아 정의된 절차에 따라 회로 노드와 연결 구조를 생성하는 핵심 로직을 담당하는 클래스. (랜덤 로직, 레이어 관리, 제약 조건 처리 포함)
* `CircuitConverter` (또는 `ExpressionConverter`, `JsonConverter`): 회로 노드 구조를 불 대수식 문자열 또는 JSON 형식으로 변환하는 기능 구현. XAND 연산 및 진리표 JSON 변환 로직 포함.
* `ComplexityCalculator`: 회로에 사용된 게이트별 난이도 점수를 합산하거나 다른 지표를 계산하는 클래스.
* **`TruthTableGenerator`:** 회로 구조와 입력 변수 수를 받아 브루트 포스 기반 시뮬레이션 (비트 연산 활용)을 통해 진리표를 생성하는 필수 클래스.

**10. 기술적 흐름 요약**

1.  **회로 생성:** 사용자 지정 조건과 랜덤 로직, 제약 조건 처리를 통해 출력 -> 입력 역방향으로 회로 구조 (DAG)를 생성합니다.
2.  **복잡성 계산:** 생성된 회로에 사용된 게이트들의 점수를 기반으로 전체 회로의 복잡성 지표를 계산합니다.
3.  **진리표 생성:** 생성된 회로 구조와 입력 변수 수를 기반으로 브루트 포스 시뮬레이션 (비트 연산 활용)을 통해 진리표를 생성합니다.
4.  **수식 변환:** 생성된 회로 구조로부터 해당 불 대수식을 생성합니다.
5.  **결과 출력:** 생성된 회로 구조 (JSON), 불 대수식 (문자열), 계산된 복잡성 지표, 생성된 진리표를 콘솔 또는 파일로 출력합니다.
